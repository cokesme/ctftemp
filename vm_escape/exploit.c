// gcc -o exp -static -nostdlib -masm=intel exploit.c

#define O_RDONLY    (0x0000)
#define O_RDWR      (0x0002)
#define O_SYNC      (0x101000)
#define SEEK_SET    (0x0)
#define PROT_READ   0x1     /* Page can be read.  */
#define PROT_WRITE  0x2     /* Page can be written.  */
#define MAP_SHARED  0x1    /* Share changes.  */

// syscall
void exit(int e) {
  __asm__("mov rax, 60");
  __asm__("syscall");
  __builtin_unreachable();
}

int read(int fd, char* buf, int size) {
  __asm__("mov rax, 0");
  __asm__("syscall");
}

int write(int fd, char* buf, int size) {
  __asm__("mov rax, 1");
  __asm__("syscall");
}

int open(char *pathname, int flags) {
  __asm__("mov rax, 2");
  __asm__("syscall");
}

int close(int fd) {
  __asm__("mov rax, 3");
  __asm__("syscall");
}

unsigned long lseek(int fd, unsigned long offset, int whence) {
  __asm__("mov rax, 8");
  __asm__("syscall");
}

void *mmap(void *addr, unsigned long length, int prot, int flags, int fd, unsigned long offset) {
        __asm__("mov r10, rcx");
        __asm__("mov rax, 9");
  __asm__("syscall");
}


unsigned char* iomem;

void iowrite(unsigned long offset, unsigned char value) {
    iomem[offset] = value;
}

unsigned long ioread(unsigned long offset) {
    return iomem[offset];
}


// helper functions
unsigned long strlen(char* buf) {
    unsigned long i = 0;
    while( buf[i] != '\x00') {i++;}
    return i;
}

void puts(char *buf) {
    write(1, buf, strlen(buf));
}


// main part exploit
void _start(void) {
    int fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC);
    if (fd < 0) {
        //raw systemcall return errno
        puts("open error\n");
        exit(fd);
    }
    puts("open success\n");
    iomem = mmap(0, 0x1000000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if((unsigned long)iomem == -1){puts("mmap failure.");exit(-1);}



}
